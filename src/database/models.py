"""
SQLAlchemy database models for the trading system.
"""

from datetime import datetime
from sqlalchemy import (
    Column,
    Integer,
    String,
    Float,
    Boolean,
    DateTime,
    Text,
    ForeignKey,
    ARRAY,
    create_engine,
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, sessionmaker
from sqlalchemy.pool import QueuePool

Base = declarative_base()


class Market(Base):
    """Kalshi markets"""

    __tablename__ = "markets"

    ticker = Column(String(50), primary_key=True)
    title = Column(Text)
    category = Column(String(50))
    close_date = Column(DateTime)
    status = Column(String(20))
    volume_24h = Column(Float)
    last_price = Column(Float)
    yes_bid = Column(Float)
    yes_ask = Column(Float)
    no_bid = Column(Float)
    no_ask = Column(Float)
    open_interest = Column(Float)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    signals = relationship("Signal", back_populates="market")
    trades = relationship("Trade", back_populates="market")

    def __repr__(self):
        return f"<Market {self.ticker}>"


class NewsEvent(Base):
    """News events from monitoring"""

    __tablename__ = "news_events"

    id = Column(Integer, primary_key=True)
    event_id = Column(String(100), unique=True, index=True)
    timestamp = Column(DateTime, index=True)
    source = Column(String(50))
    event_type = Column(String(50))
    headline = Column(Text)
    content = Column(Text)
    keywords = Column(ARRAY(String))  # PostgreSQL array
    entities = Column(ARRAY(String))
    related_tickers = Column(ARRAY(String))
    reliability_score = Column(Float)
    url = Column(Text, nullable=True)
    processed = Column(Boolean, default=False, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f"<NewsEvent {self.event_id[:20]}...>"


class Signal(Base):
    """Trading signals generated by strategies"""

    __tablename__ = "signals"

    id = Column(Integer, primary_key=True)
    signal_id = Column(String(100), unique=True, index=True)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    source = Column(String(50), index=True)  # Strategy name
    ticker = Column(String(50), ForeignKey("markets.ticker"), index=True)
    side = Column(String(10))  # 'yes' or 'no'
    signal_type = Column(String(20))  # 'BUY', 'SELL'
    confidence = Column(Float)  # 0-1
    edge_percentage = Column(Float)  # Expected edge
    market_price = Column(Float)
    fair_value = Column(Float)
    reasoning = Column(Text)
    news_event_id = Column(Integer, ForeignKey("news_events.id"), nullable=True)
    executed = Column(Boolean, default=False, index=True)
    executed_at = Column(DateTime, nullable=True)
    rejected = Column(Boolean, default=False)
    rejection_reason = Column(Text, nullable=True)

    # Relationships
    market = relationship("Market", back_populates="signals")
    news_event = relationship("NewsEvent")
    trades = relationship("Trade", back_populates="signal")

    def __repr__(self):
        return f"<Signal {self.signal_id}>"


class Trade(Base):
    """Executed trades"""

    __tablename__ = "trades"

    id = Column(Integer, primary_key=True)
    signal_id = Column(Integer, ForeignKey("signals.id"), nullable=True)
    order_id = Column(String(50), unique=True)
    ticker = Column(String(50), ForeignKey("markets.ticker"), index=True)
    side = Column(String(10))  # 'yes' or 'no'
    quantity = Column(Integer)
    entry_price = Column(Float)
    fill_price = Column(Float, nullable=True)
    exit_price = Column(Float, nullable=True)
    fees = Column(Float, default=0)
    pnl = Column(Float, nullable=True)
    executed_at = Column(DateTime, default=datetime.utcnow, index=True)
    closed_at = Column(DateTime, nullable=True)
    status = Column(
        String(20), default="open"
    )  # 'open', 'closed', 'cancelled', 'failed'
    close_reason = Column(
        String(50), nullable=True
    )  # 'take_profit', 'stop_loss', 'timeout', 'manual'

    # Relationships
    signal = relationship("Signal", back_populates="trades")
    market = relationship("Market", back_populates="trades")

    def __repr__(self):
        return f"<Trade {self.order_id}>"


class Position(Base):
    """Current open positions (denormalized for quick access)"""

    __tablename__ = "positions"

    id = Column(Integer, primary_key=True)
    ticker = Column(String(50), unique=True, index=True)
    side = Column(String(10))
    quantity = Column(Integer)
    entry_price = Column(Float)
    current_price = Column(Float)
    unrealized_pnl = Column(Float)
    opened_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self):
        return f"<Position {self.ticker} {self.quantity}@{self.entry_price}>"


class PerformanceMetrics(Base):
    """Daily performance metrics"""

    __tablename__ = "metrics"

    date = Column(DateTime, primary_key=True)
    total_trades = Column(Integer, default=0)
    winning_trades = Column(Integer, default=0)
    losing_trades = Column(Integer, default=0)
    total_pnl = Column(Float, default=0)
    total_fees = Column(Float, default=0)
    net_pnl = Column(Float, default=0)
    win_rate = Column(Float, default=0)
    avg_win = Column(Float, default=0)
    avg_loss = Column(Float, default=0)
    sharpe_ratio = Column(Float, nullable=True)
    max_drawdown = Column(Float, nullable=True)
    avg_latency_ms = Column(Integer, nullable=True)
    portfolio_value = Column(Float, nullable=True)

    def __repr__(self):
        return f"<Metrics {self.date.date()} PnL=${self.net_pnl:.2f}>"


class SystemLog(Base):
    """System logs and errors"""

    __tablename__ = "system_logs"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
    level = Column(String(20))  # DEBUG, INFO, WARNING, ERROR, CRITICAL
    source = Column(String(50))  # Module name
    message = Column(Text)
    exception = Column(Text, nullable=True)

    def __repr__(self):
        return f"<SystemLog {self.level} {self.timestamp}>"


# Database connection and session management


class Database:
    """Database connection manager"""

    def __init__(self, database_url: str):
        self.database_url = database_url
        self.engine = create_engine(
            database_url,
            poolclass=QueuePool,
            pool_size=10,
            max_overflow=20,
            pool_timeout=30,
            pool_pre_ping=True,  # Verify connections before using
        )
        self.SessionLocal = sessionmaker(
            autocommit=False, autoflush=False, bind=self.engine
        )

    def create_tables(self):
        """Create all tables"""
        Base.metadata.create_all(bind=self.engine)

    def drop_tables(self):
        """Drop all tables (use with caution!)"""
        Base.metadata.drop_all(bind=self.engine)

    def get_session(self):
        """Get a database session"""
        return self.SessionLocal()

    def close(self):
        """Close the engine"""
        self.engine.dispose()


# Helper functions for common queries


def get_open_positions(session):
    """Get all open positions"""
    return session.query(Position).all()


def get_recent_signals(session, limit=100):
    """Get recent signals"""
    return (
        session.query(Signal)
        .order_by(Signal.timestamp.desc())
        .limit(limit)
        .all()
    )


def get_unexecuted_signals(session):
    """Get signals that haven't been executed"""
    return (
        session.query(Signal)
        .filter(Signal.executed == False, Signal.rejected == False)
        .order_by(Signal.timestamp.desc())
        .all()
    )


def get_trades_by_date(session, start_date, end_date):
    """Get trades within date range"""
    return (
        session.query(Trade)
        .filter(Trade.executed_at >= start_date, Trade.executed_at <= end_date)
        .all()
    )


def get_open_trades(session):
    """Get all open trades"""
    return session.query(Trade).filter(Trade.status == "open").all()


def calculate_daily_metrics(session, date):
    """Calculate performance metrics for a day"""
    start = datetime.combine(date, datetime.min.time())
    end = datetime.combine(date, datetime.max.time())

    trades = get_trades_by_date(session, start, end)

    if not trades:
        return None

    total_trades = len(trades)
    winning_trades = len([t for t in trades if t.pnl and t.pnl > 0])
    losing_trades = len([t for t in trades if t.pnl and t.pnl < 0])

    total_pnl = sum(t.pnl for t in trades if t.pnl)
    total_fees = sum(t.fees for t in trades if t.fees)
    net_pnl = total_pnl - total_fees

    win_rate = winning_trades / total_trades if total_trades > 0 else 0

    avg_win = (
        sum(t.pnl for t in trades if t.pnl and t.pnl > 0) / winning_trades
        if winning_trades > 0
        else 0
    )

    avg_loss = (
        sum(t.pnl for t in trades if t.pnl and t.pnl < 0) / losing_trades
        if losing_trades > 0
        else 0
    )

    # Create or update metrics
    metrics = (
        session.query(PerformanceMetrics)
        .filter(PerformanceMetrics.date == start)
        .first()
    )

    if not metrics:
        metrics = PerformanceMetrics(date=start)
        session.add(metrics)

    metrics.total_trades = total_trades
    metrics.winning_trades = winning_trades
    metrics.losing_trades = losing_trades
    metrics.total_pnl = total_pnl
    metrics.total_fees = total_fees
    metrics.net_pnl = net_pnl
    metrics.win_rate = win_rate
    metrics.avg_win = avg_win
    metrics.avg_loss = avg_loss

    session.commit()
    return metrics
